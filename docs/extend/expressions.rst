.. _extend_expressions:

Expressions
===========

Expressions are one of the most integral parts of stylo. They are a
representation of some mathematical expression which can be inspected,
evaluated and even saved and loaded from data formats such as JSON. This page
will only focus on using an expression once it has been constructed. There are
however a number of other documents available:

- <A document/tutorial on writing expression compatible functions.>
- <A document/tutorial on extending the system.>
- <A document on the implementation of the core system.>

.. todo::

   Make these documents exist.

Perhaps the easiest way to construct an expression for us to look at is to use
the |trace| decorator. For the purposes of this document we will be looking at
a simple :code:`add` function::

   >>> import stylo as st

   >>> @st.trace
   ... def add(x, y):
   ...     return x + y

   >>> add
   (+ x y)

.. _extend_expressions_eval:

Evaluating Expressions
----------------------

Using the |Expression.eval| method we can compute the value of an expression.
There are a number of ways in which an expression can be evaluated.

- |_Constant Expressions|
- |_With Numbers|
- |_With Numpy Arrays|
- |_Partial Evaluation|

.. |_Constant Expressions| replace:: :ref:`extend_expressions_eval_const`
.. |_With Numbers| replace:: :ref:`extend_expressions_eval_nums`
.. |_With Numpy Arrays| replace:: :ref:`extend_expressions_eval_numpy`
.. |_Partial Evaluation| replace:: :ref:`extend_expressions_eval_partial`

.. _extend_expressions_eval_const:

Constant Expressions
^^^^^^^^^^^^^^^^^^^^

The simplest kind of expression to evaulate is a constant one i.e. an
expression that contains no variables. In this case all we need to do is to
call the |Expression.eval| method directly::

    >>> one = st.Const(1)
    >>> two = st.Const(2)

    >>> plus = one + two
    >>> plus
    (+ 1 2)

    >>> plus.eval()
    3

.. _extend_expressions_eval_nums:

With Numbers
^^^^^^^^^^^^

Once you have an expression that contains variables, it's possible to evaluate
provide values to those variables by passing in a dictionary to the
|Expression.eval| method::

   >>> add
   (+ x y)

   >>> add.eval({'x': -1, 'y': 2.5})
   1.5

.. _extend_expressions_eval_numpy:

With Numpy Arrays
^^^^^^^^^^^^^^^^^

Expressions are not just limited to numbers they work just as well with numpy
arrays (assuming their shapes are compatble)::

   >>> import numpy as np
   >>> add
   (+ x y)

   >>> add.eval({'x': np.array([1, 2, 3]), 'y': np.array([1, 0, -1])})
   array([2, 2, 2])

.. _extend_expressions_eval_partial:

Partial Evaluation
^^^^^^^^^^^^^^^^^^

By default expressions will support partial evaluation, that means that you can
specify values of only some of the variables in an expression without an error
being thrown. The result of a partially evaluated expression will be another
expression object this time only containing the variables you did not
specify. For example if we were only to specify a value for :code:`x` in our
:code:`add` expression we would get the following result::

    >>> add
    (+ x y)

    >>> add.eval({'x': 1})
    (+ 1 y)

However if you want your expression to be totally evaluated and for an error to
be thrown if any variables were not assigned values, then you can pass the
:code:`total=True` as a keyword argument to the |Expression.eval| method::

    >>> add.eval({'x': 1}, total=True)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
       ...
    NameError: Variable 'y' is not defined

.. _extend_expressions_json:

Converting To and From JSON
---------------------------

Given some expression you can convert it into an equivalent JSON representation
by calling the |Expression.json| method::

    >>> add.json()
    '{"Plus": {"a": {"Name": {"name": "x"}}, "b": {"Name": {"name": "y"}}}}'

A more human readable representation can be generated by passing the
:code:`pretty=True` flag to the method::

    >>> print(add.json(pretty=True))
    {
      "Plus": {
        "a": {
          "Name": {
            "name": "x"
          }
        },
        "b": {
          "Name": {
            "name": "y"
          }
        }
      }
    }

If you have some expression that is represented as a JSON object you can convert
this back into an |Expression| using the |Expression.fromjson| method::

  >>> json = '{"Multiply": {"a": {"Name": {"name": "x"}}, "b": {"Name": {"name": "y"}}}}'
  >>> multiply = st.Expression.fromjson(json)
  >>> multiply
  (* x y)

  >>> multiply.eval({'x': 2, 'y': 3})
  6
