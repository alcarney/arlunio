import random
import string
import inspect

from stylo.math import StyName


NAMECHARS = string.ascii_letters + string.digits
SHAPE_DOCSTRING = """\
I am a shape :)
"""


def _gen_name(base):
    """Generate a name based on the input so that we can combine shapes without
    worrying too much about parameter name collision in expressions."""
    return base + "_" + "".join(random.choices(NAMECHARS, k=12))


def _normalise_name(name):
    """Given a name return the "normalised" name. i.e. if the name has a suffix
    like the one generated by the :code:`_gen_name` function strip it off."""

    if "_" not in name:
        return name

    return name[: name.find("_")]


def _set_parameters(defaults, overrides):
    """Build a parameter dictionary based on the defaults, but take note of any
    overrides."""

    params = {}

    bad_params = [k for k in overrides.keys() if k not in defaults]

    if bad_params != []:
        message = "__init__() got unexpected keyword argument '{}'"
        raise TypeError(message.format(bad_params[0]))

    for key, value in defaults.items():

        if key in overrides:
            value = overrides[key]

        params[_gen_name(key)] = value

    return params


def _shape_init(func, defaults):
    """Given the default parameter dictionary construct the init method for the
    shape."""

    def init(self, **kwargs):
        self._params = _set_parameters(defaults, kwargs)
        self._func = func
        self._expr = None

    return init


def _shape_repr(self):
    """This function is the implementation of the __repr__ method for the shape
    class."""

    name = self.__class__.__name__
    ps = ["{}={}".format(k[: k.find("_")], v) for k, v in self._params.items()]

    return "{}({})".format(name, ", ".join(ps))


def _shape_call(self, *args, **kwargs):
    """This function allows us to use shape instances like a function."""

    # Start off with any positional arguments.
    arguments = {name: value for value, name in zip(args, self.args)}

    # Then fill in any named domain arguments.
    for domain_arg in self.args:
        if domain_arg in kwargs:
            arguments[domain_arg] = kwargs[domain_arg]

    # Then set all the parameter values - listening to any overrides in
    # kwargs
    for key, value in self._params.items():
        name = _normalise_name(key)

        if name in kwargs:
            arguments[key] = kwargs[name]
            continue

        arguments[key] = value

    return self.expr.eval(arguments)


def _shape_expr_property():
    """This writes the definition of the :code:`expr` property."""

    def getter(self):
        args = {
            _normalise_name(name): StyName(name)
            for name in self.args + list(self._params.keys())
        }
        return self._func(**args)

    return property(fget=getter)


def _shape_parameter_property(name):
    """Given a parameter name define a property that allows people to access it."""

    def pget(self):

        for key, value in self._params.items():
            if key.startswith(name + "_"):
                return value

    def pset(self, value):

        for key in self._params.keys():

            if key.startswith(name + "_"):
                self._params[key] = value
                return

    return property(fget=pget, fset=pset)


def _define_shape_class(f, args, parameters, defaults):

    name = f.__name__
    docstring = SHAPE_DOCSTRING

    if f.__doc__ is not None:
        docstring += "\n" + f.__doc__

    attributes = {
        "__doc__": docstring,
        "__init__": _shape_init(f, defaults),
        "__repr__": _shape_repr,
        "__call__": _shape_call,
        "args": args,
        "defaults": defaults,
        "expr": _shape_expr_property(),
        "parameters": parameters,
    }

    for pname in parameters:
        attributes[pname] = _shape_parameter_property(pname)

    return type(name, tuple(), attributes)


def shape(f):
    """A decorator to define a shape using a function."""

    defaults = {} if f.__kwdefaults__ is None else f.__kwdefaults__
    params = inspect.signature(f).parameters

    parameters = [k for k in params.keys() if k in defaults]
    args = [k for k in params.keys() if k not in parameters]

    return _define_shape_class(f, args, parameters, defaults)
